== Meeting Minutes: XXHash Library Implementation and Specification Review

=== Date: February 17-18, 2026

=== Attendees: Technical Review Team

'''''

=== 1. XXHash Algorithm Overview

==== 1.1 Algorithm Families

* *XXH32*: Classic 32-bit hash algorithm.
  _Wrapper export_: `xxh32()` — scalar-only, no SIMD variants, legacy use.
* *XXH64*: Classic 64-bit hash algorithm.
  _Wrapper export_: `xxh64()` — scalar-only, no SIMD variants; recommended as the
  high-performance scalar fallback when SIMD is not available, as its simpler
  accumulation loop may outperform `xxh3_64_scalar()` on non-SIMD CPUs.
* *XXH3*: Modern, highly optimized hash suite with multiple variants.
  _Wrapper export_: `xxh3_64_<variant>()` and `xxh3_128_<variant>()` — one named
  symbol per SIMD variant (scalar, SSE2, AVX2, AVX512, NEON, SVE); consumers
  select variant; no internal dispatch in the wrapper.

==== 1.2 Performance Characteristics

* Achieves speeds at the limits of RAM performance
* Vectorized implementations reach 29.6 GB/s to 59.4 GB/s depending on
instruction set
* Optimized for both small and large inputs

'''''

=== 2. Vectorization and SIMD Support

==== 2.1 Supported Instruction Sets

* *x86/x64*: SSE2, AVX2, AVX512
* *ARM*: NEON, SVE (Scalable Vector Extension)
* *PowerPC*: VSX (Vector Scalar Extension)
* *Other*: ZVector (s390x), WASM SIMD128, LoongArch (LSX, LASX), RISC-V
Vector (RVV)

==== 2.2 Implementation Strategy

* Manual vectorization preferred over compiler auto-vectorization
* Runtime dispatcher for x86/x64 platforms to select optimal instruction
set
* Compile-time selection for other architectures

==== 2.3 Performance by Architecture

* *AVX2*: ~59.4 GB/s
* *SSE2*: ~31.5 GB/s +
* *NEON*: Optimized for Cortex-A73/A76 cores
* *SVE*: Optimized for ARMv8.2 and newer

'''''

=== 3. XXH3 Algorithm Details

==== 3.1 XXH3++_++128bits Variant

* Produces 128-bit hash using XXH128++_++hash++_++t structure (low64,
high64)
* Performance: 29.6-57.9 GB/s with vectorization
* Higher collision resistance than 64-bit variant
* Avoids theoretical seed-dependent multi-collisions

==== 3.2 Input Length Adaptation

* *0-16 bytes*: Specialized mixing logic
* *17-240 bytes*: Standard processing
* *++>++240 bytes*: Large input optimization with 8 accumulators

==== 3.3 Security Features

* *Seeds*: 64-bit values for predictable randomization
* *Secrets*: 136-192 byte blobs for collision resistance
* *XXH3++_++generateSecret()*: Function to derive high-entropy secrets
from custom seeds

'''''

=== 4. Build System Architecture

==== 4.1 Dual Build Systems

* *Makefile*: Optimized for UNIX-like systems, supports
cross-compilation
* *CMake*: Cross-platform support, Visual Studio integration

==== 4.2 Header-Only Mode

* *XXH++_++INLINE++_++ALL*: Transforms library into header-only
implementation
* Performance gains of 200%{plus} for compile-time constant lengths
* Eliminates linking overhead

==== 4.3 Build Modifiers

* *XXH++_++SIZE++_++OPT*: Size optimization vs performance trade-off
* *XXH++_++NO++_++XXH3*: Disable XXH3 family
* *XXH++_++NO++_++STREAM*: Disable streaming APIs
* *XXH++_++VECTOR*: Manual vector instruction set selection

'''''

=== 5. Architecture-Specific Implementations

==== 5.1 ARM Support

* *AArch64*: NEON standard, SVE for ARMv8.2{plus}
* *ARMv7-A*: NEON acceleration, scalar fallback
* *Embedded*: ARMv6 with UMAAL DSP instruction, Thumb-2 support
* *Apple Silicon*: Explicit detection and optimization

==== 5.2 S390X Implementation

* Uses VSX code path shared with PowerPC
* ZVector instruction set support
* Runtime testing via QEMU emulation

==== 5.3 Cross-Compilation

* Active CI testing for cross-compilation scenarios
* Support for building ARM64 on AMD64 environments
* Known issues with CMake dispatcher detection requiring explicit
disable

'''''

=== 6. Runtime Dispatcher Mechanism

==== 6.1 x86/x64 Dispatcher (Vendor Implementation — NOT used by wrapper)

[IMPORTANT]
====
The vendor xxHash dispatcher described here is the *upstream library's* internal mechanism.
The xxhash-wrapper project *does NOT use* this mechanism.
See <<wrapper-design>> for the wrapper's export-based approach.
====

* *XXH_featureTest*: Hierarchical capability detection
* *CPUID*: Hardware feature verification
* *XGETBV*: OS support verification for extended registers
* *Function Pointer Assignment*: Dynamic selection of optimal
implementation

==== 6.2 Architecture Limitations

* Dispatcher exclusive to x86/x64 platforms
* Compile-time selection for ARM, PowerPC, S390X
* Explicit error on non-x86 platforms

[[wrapper-design]]
==== 6.3 xxhash-wrapper Design: Multi-Variant Export (No Internal Dispatch)

The wrapper project takes a *different approach* from the vendor dispatcher:

* *All SIMD variants are exported as separately named public symbols*: `xxh3_64_scalar()`, `xxh3_64_sse2()`, `xxh3_64_avx2()`, `xxh3_64_avx512()`, `xxh3_64_neon()`, `xxh3_64_sve()`, and equivalents for 128-bit and streaming APIs.
* *The library contains no internal dispatch logic*: no CPUID calls, no function pointer tables.
* *CPU detection and variant selection are the consumer's responsibility*: a language binding (e.g. cr-xxhash) or application performs CPU feature detection (CPUID + XGETBV) and calls the appropriate exported symbol.
* *Rationale*: Gives consumers full control over dispatch strategy (runtime, compile-time, config-file, environment variable, etc.) without forcing a single opinionated approach into the library.

Example consumer dispatch pattern:

[source,c]
----
// Consumer-side (e.g. Crystal FFI layer) pseudocode
// xxh32() and xxh64() are always available without any capability check.
// Use xxh64() as the scalar fallback: simpler algorithm, often faster than
// xxh3_64_scalar() on non-SIMD CPUs.
if (cpu_has_avx512()) {
    result = xxh3_64_avx512(input, size, seed);
} else if (cpu_has_avx2()) {
    result = xxh3_64_avx2(input, size, seed);
} else if (cpu_has_sse2()) {
    result = xxh3_64_sse2(input, size, seed);
} else {
    // No SIMD: prefer xxh64() over xxh3_64_scalar() for better throughput
    result = xxh64(input, size, (uint64_t)seed);
}
----

'''''

=== 7. Implementation Details (Vendor Internals)

[NOTE]
====
This section describes vendor xxHash internals for reference.
The wrapper does *not* use these macros or the vendor dispatch mechanism.
See <<wrapper-design>> for the wrapper's approach.
====

==== 7.1 Vendor Function Generation

* *x86*: `XXH_DEFINE_DISPATCH_FUNCS` macro for runtime
selection (vendor only)
* *ARM*: Compile-time mapping via `XXH_VECTOR` macro
* *S390X/PowerPC*: Shared VSX code path with architecture-specific
intrinsics

==== 7.2 Namespace Management

* *XXH++_++NAMESPACE*: Prefixes all public API symbols
* Enables multiple library versions in single binary
* Prevents symbol collisions

==== 7.3 Special Export Requirements

* Custom xxhash++_++export.c files for multi-variant exports
* Target attributes for instruction set isolation
* Wrapper functions for public API exposure

'''''

=== 8. Quality Assurance and Testing

==== 8.1 CI Matrix

* Extensive compiler testing (GCC 4.8-14, Clang, MSVC)
* Architecture validation (x86, ARM, PowerPC, S390X)
* Special test cases (c90test, nostdlibtest)

==== 8.2 Performance Validation

* Benchmark integration with inline implementations
* Collision detection testing
* Cross-platform consistency verification

'''''

=== 9. Key Technical Decisions

[arabic]
. *Manual vs Auto Vectorization*: Manual vectorization preferred due to
compiler inefficiencies
. *Runtime vs Compile-time Selection (vendor)*: Vendor uses runtime for x86/x64, compile-time
for other architectures
. *Wrapper Dispatch Strategy*: The wrapper exports *all SIMD variants as separate named functions*;
no internal dispatch. Consumers implement CPU detection and variant selection themselves.
. *Language Standard*: C99 (`-std=c99`) for all wrapper code; no C11 or compiler extensions.
. *Versioning Strategy*: Numeric Quad (`MAJOR.MINOR.PATCH.WRAPPER_PATCH`). Matches vendor for
the first 3 digits (currently `0.8.3`), fourth digit is for the wrapper itself (`0.8.3.0`).
. *Commit & Git Workflow*: Use **Conventional Commits** for clear history and automation.
. *Branching Strategy*: Final decision pending (proposals: GitHub Flow, GitLab Flow, Trunk-Based).
. *Header-Only Implementation*: Not used by wrapper (library-only mode; dynamic/static linking).
. *Cross-Platform Strategy*: Meson build system; x86/x64 exports all SIMD variants
unconditionally; ARM exports NEON/SVE only when compiled for aarch64.
. *Secret Wiping Strategy*: **No Wiping**; clearing secret material from memory is the responsibility of the caller to maximize performance and minimize complexity.

'''''

=== 10. Action Items

[arabic]
. *Documentation*: Update architecture-specific build guides
. *Testing*: Expand CI coverage for emerging architectures
. *Performance*: Investigate auto-vectorization improvements for
Zen4{plus}
. *Security*: Review secret generation entropy requirements
. *Workflow*: Finalize and document the branching strategy selection.
. *Linting*: Implement `commitlint` for Conventional Commit enforcement.

'''''

=== 11. Technical Questions Addressed

[arabic]
. *XXH3_128bits*: 128-bit variant with improved collision resistance
. *Vectorization*: Manual SIMD implementation across multiple
architectures
. *Build System*: Meson (exclusive; no CMake or Makefile); C99 standard for wrapper code
. *Multi-Variant Export*: Wrapper exports all SIMD variants as named symbols; no internal dispatch
. *Cross-Compilation*: Supported with known limitations
. *No Dispatcher in Wrapper*: x86/x64 dispatch is consumer-side (CPUID + XGETBV)
. *Secret Wiping*: No internal wiping of secret material (caller's responsibility).

'''''

=== 12. Conclusion

The XXHash library demonstrates sophisticated engineering with: -
High-performance hash algorithms optimized for modern hardware -
Comprehensive cross-platform support - Flexible build system
accommodating various use cases - Strong focus on both performance and
portability

The implementation successfully balances the competing demands of speed,
compatibility, and maintainability across diverse computing
environments.

'''''

=== 13. Project Integration and Build System

==== 13.1 Repository Integration Strategy

* *Official Repository*: https://github.com/Cyan4973/xxHash
* *Integration Method*: Git submodule in `vendor/xxHash` directory
* *Rationale*: Clean separation of third-party dependencies, easy
updates, and clear project structure

==== 13.2 Build System Architecture

* *Primary Build System*: Meson (replacing CMake and Makefile approaches)
* *Language Standard*: C99 (`-std=c99`) for all wrapper source code (`src/`, `include/`); no C11 or compiler extensions
* *Build Configuration*: Static library compilation with custom wrapper
code

==== 13.3 Multi-Variant Export Architecture

The wrapper compiles all applicable SIMD variants into the library and exports each as a distinct symbol:

[cols="1,2,2"]
|===
|Platform |Exported Variants |Notes

|All platforms
|`xxh32`, `xxh64`
|Scalar-only; no variant suffix; always exported.
`xxh64` recommended as scalar fallback when no SIMD

|x86/x64
|`xxh3_64_scalar`, `xxh3_64_sse2`, `xxh3_64_avx2`, `xxh3_64_avx512`
|All four always present in every x86/x64 build

|aarch64
|`xxh3_64_scalar`, `xxh3_64_neon`, `xxh3_64_sve`
|SVE only when `-Dcpu_family` target supports ARMv8.2+
|===

* 128-bit and streaming variants follow the same `xxh3_128_<variant>` and `xxh3_64_<variant>_reset/update/digest` naming pattern.
* CPU feature detection and variant selection are *consumer-side* concerns.

==== 13.3 Project Structure
....
xxhash-wrapper/
├── vendor/
│   └── xxHash/          # Git submodule with official source
├── src/                 # C99 wrapper implementation
├── include/             # Public header files
├── meson.build          # Main Meson build configuration
├── subprojects/         # Optional Meson subproject definitions
└── .gitmodules          # Git submodule configuration
....

==== 13.4 Meson Integration Details

* *Subproject Integration*: `subproject('xxHash')` for dependency
management
* *Wrapper Library*: Custom C99 wrapper around xxHash functionality
* *Build Targets*: Static library compilation with C99 standard
compliance
* *Dependency Management*: Clear separation between vendor code and
wrapper implementation

==== 13.5 Integration Benefits

* *Maintainability*: Easy updates to official xxHash source
* *Build Clarity*: Clear distinction between vendor and project code
* *Portability*: Meson’s cross-platform build capabilities
* *Standards Compliance*: C99 standard for wrapper code ensures modern C
features
* *Flexibility*: Easy to swap out or update the underlying xxHash
implementation

==== 13.6 Implementation Considerations

* *Wrapper Design*: C99-compliant wrapper functions around xxHash API
* *Build Configuration*: Static linking of vendor xxHash with wrapper
library
* *Testing Strategy*: Integration testing of wrapper with official
xxHash implementation
* *Documentation*: Clear build instructions for Meson-based development

This integration approach provides a robust, maintainable foundation for
the xxHash wrapper project while leveraging the official source code and
modern build system capabilities.

'''''

=== 14. Documentation Strategy and Organization

==== 14.1 Simplified Documentation Structure

For this simple wrapper project, a streamlined documentation approach
was chosen:

....
specs/
├── index.adoc                   # Main documentation entry point
├── api/                        # API documentation
│   ├── overview.adoc
│   ├── xxh3.adoc
│   └── examples.adoc
├── build/                      # Build instructions
│   └── meson.adoc
└── notes/                      # Meeting minutes and notes
    ├── 2026-02-19-meeting.adoc # Meeting minutes with date (AsciiDoc format)
    ├── 2026-02-18-discussion.adoc # Discussion notes (AsciiDoc format)
    └── changelog.adoc          # Project changelog (AsciiDoc format)
....

==== 14.2 File Naming Convention

* *Meeting minutes and notes*: `YYYY-MM-DD-description.adoc` (AsciiDoc
format)
* *Examples*: Descriptive names like `basic-usage.adoc`,
`streaming.adoc`
* *API documentation*: Function-specific names like `xxh3.adoc`,
`overview.adoc`

==== 14.3 Documentation Focus Areas

[arabic]
. *Core API documentation* - What the wrapper provides
. *Build instructions* - How to build the wrapper
. *Quick examples* - Simple usage examples
. *Meeting notes* - Keep track of decisions and discussions

==== 14.4 Rationale for Simplification
* *Maintainability*: Easier to keep documentation up-to-date
* *Navigation*: Clear, logical structure for users
* *Focus*: Emphasizes essential information for a wrapper project
* *Efficiency*: Reduces documentation overhead while maintaining clarity

This simplified approach provides the right balance of documentation for
a wrapper project while maintaining clarity and ease of maintenance.

'''''

=== 15. Documentation Format and Structure Updates

==== 15.1 Documentation Format Decision

* *Primary Format*: AsciiDoc for all documentation files
* *Exception*: Top-level README.md remains in Markdown format
* *Rationale*: AsciiDoc provides better formatting capabilities for
technical documentation while maintaining compatibility with GitHub
rendering

==== 15.2 Updated Documentation Structure

....
specs/
├── index.adoc                   # Main documentation entry point
├── api/                        # API documentation
│   ├── overview.adoc
│   ├── xxh3.adoc
│   └── examples.adoc
├── build/                      # Build instructions
│   └── meson.adoc
└── notes/                      # Meeting minutes and notes
    ├── 2026-02-19-meeting.adoc # Meeting minutes with date (AsciiDoc format)
    ├── 2026-02-18-discussion.adoc # Discussion notes (AsciiDoc format)
    └── changelog.adoc          # Project changelog (AsciiDoc format)
....

==== 15.3 File Naming Convention

* *Meeting minutes and notes*: `YYYY-MM-DD-description.adoc` (AsciiDoc
format)
* *Examples*: Descriptive names like `basic-usage.adoc`,
`streaming.adoc`
* *API documentation*: Function-specific names like `xxh3.adoc`,
`overview.adoc`

==== 15.4 Benefits of AsciiDoc Format

* *Rich Formatting*: Better support for tables, code blocks, and
cross-references
* *Consistency*: Uniform format across all documentation
* *Maintainability*: Easier to maintain and update documentation
* *Compatibility*: Works well with GitHub and other documentation
platforms

==== 15.5 Implementation Considerations

* *Conversion*: Existing Markdown files need to be converted to AsciiDoc
* *Tooling*: Ensure AsciiDoc tools are available in the development
environment
* *Documentation*: Update documentation to reflect AsciiDoc format
requirements
* *Examples*: Provide AsciiDoc formatting examples in documentation

This documentation format update provides better formatting capabilities
while maintaining the simplified structure that works well for a wrapper
project.

'''''

=== 16. Build System Decision

==== 16.1 Build System Choice

* *Build System*: Meson is the exclusive build system for this project
* *Rationale*: Meson provides better cross-platform support, cleaner
configuration, and more modern build capabilities compared to traditional
Makefile and CMake approaches
* *Implementation*: All build processes will be handled through Meson
configuration files
* *Vendor Integration*: xxHash will be integrated as a Meson subproject

==== 16.2 Build System Benefits

* *Simplicity*: Single build system approach reduces complexity
* *Modern Features*: Meson offers modern build features and better
dependency management
* *Cross-Platform*: Excellent cross-platform support with consistent
behavior
* *Performance*: Faster build times and better incremental builds
* *Maintainability*: Cleaner configuration files and easier maintenance

This build system decision ensures a streamlined development experience
while maintaining compatibility with the xxHash library and supporting
the project's requirements.

'''''

=== 17. Versioning Strategy

==== 17.1 Numeric Quad Scheme

The wrapper follows a **Numeric Quad** versioning scheme: `MAJOR.MINOR.PATCH.WRAPPER_PATCH`.

* **MAJOR.MINOR.PATCH**: These first three digits MUST strictly match the version of the
vendored xxHash library (currently `0.8.3`).
* **WRAPPER_PATCH**: The fourth digit is a sequential number for the wrapper project itself.
This allows the wrapper to release mandatory fixes, documentation updates,
or ABI-compatible improvements independently of the vendor version.

==== 17.2 Example Release Scenarios

* **Vendor Release**: Upgrading to a new vendor version (e.g., `0.8.4`) will reset the wrapper
patch to `0`. The release version would be `0.8.4.0`.
* **Wrapper Fix**: A bug fix in the wrapper code for a vendor's `0.8.3` release would increment
the fourth digit: `0.8.3.1`, `0.8.3.2`, etc.

==== 17.3 Rationale

This scheme provides a clear link to the underlying algorithm version while
providing the flexibility to maintain the wrapper's quality and stability
independently.

'''''

=== 18. Commit Message Standard: Conventional Commits

==== 18.1 Overview
The project adopts **Conventional Commits** (v1.0.0) for all changes. This provides a clear,
structured history and enables automatic changelog generation and versioning.

==== 18.2 Format
Commits must follow the specified structure:
----
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
----

==== 18.3 Supported Types
* **feat**: New functionality (e.g., AVX512 implementation).
* **fix**: Bug fix (e.g., incorrect CPUID bit check).
* **docs**: Documentation-only changes.
* **perf**: Performance optimizations.
* **refactor**: Code change that neither fixes bugs nor adds features.
* **test**: Adding or correcting tests.
* **chore**: Build system updates, dependencies, etc.

==== 18.4 Benefits
* **Better logs**: Easy to scan for functional changes vs maintenance.
* **Tooling**: Enables `standard-version` or `release-it` to manage Numeric Quad increments.
* **CI/CD**: Allows triggers to differentiate between documentation fixes and binary logic.

'''''

=== 19. Git Branching Strategy Proposals

The following strategies (based on AB Tasty's review) were evaluated for the wrapper's needs:

==== 19.1 Proposal A: GitHub Flow
* **How**: Single `main` branch. Short-lived feature branches merged via Pull Request.
* **Rating**: ⭐⭐⭐⭐
* **Pros**: Simple, fast, native to GitHub. Good for a small team starting out.
* **Cons**: No native way to maintain "Older Vendor Versions" if we need fixes for `0.8.2` while `0.8.3` is current.

==== 19.2 Proposal B: GitLab Flow (Release Branches)
* **How**: `main` is production code. Create `0.8.3.x` branches for stable releases corresponding to vendor versions.
* **Rating**: ⭐⭐⭐⭐⭐ (RECOMMENDED)
* **Pros**: Best fit for our **Numeric Quad scheme**. We can have simultaneous support for different vendor versions via long-lived release branches.
* **Cons**: Slightly higher management overhead than pure GitHub Flow.

==== 19.3 Proposal C: GitFlow
* **How**: `main` (production), `develop` (staging), `feature/*`, `release/*`, `hotfix/*`.
* **Rating**: ⭐⭐
* **Pros**: Extremely rigid and historical.
* **Cons**: Overkill for a wrapper. High complexity/noise for a small team.

==== 19.4 Proposal D: Trunk-Based Development
* **How**: All devs commit directly to a single branch (or via PR every few hours).
* **Rating**: ⭐⭐⭐
* **Pros**: Maximum speed, avoids merge hell.
* **Cons**: Risks breaking dependent shards (like `cr-xxhash`) if a bad commit hits main before the CI gate completes fully.

==== 19.5 Decision: GitLab Flow (with Release Branches)
The project adopts **GitLab Flow with Release Branches** as its official branching strategy.

* **Primary Branch**: `main` (Production-ready code). Note: We use `main`, not `master`.
* **Release Branches**: `vMAJOR.MINOR.PATCH.x` (e.g., `v0.8.3.x`). These are long-lived branches for maintaining specific vendor versions.
* **Feature Branches**: `XXX-description` (e.g., `001-xxh3-simd-wrapper`). Merged into `main` via Merge/Pull Request.

==== 19.6 Rationale
This strategy best supports our **Numeric Quad versioning** and the need to maintain stable releases for specific `xxHash` vendor versions while continuing development on `main`.

'''''

=== 20. Inclusive Naming Standard

==== 20.1 Commitment
The project follows the guidelines from link:https://inclusivenaming.org/[Inclusive Naming Initiative] to ensure a welcoming and professional environment for all contributors and users.

==== 20.2 Key Practices
* **Branching**: Use `main` as the default branch name.
* **Terminology**: Avoid exclusionary language in code, comments, and documentation.
* **Replacement Examples**:
** Use `primary/secondary` or `leader/follower` instead of `master/slave` (if applicable).
** Use `allowlist/denylist` instead of `whitelist/blacklist`.
** Use `placeholder` or `stub` instead of `dummy`.
** Use `validation` or `consistency check` instead of `sanity check`.

==== 20.3 Scope of Application
The inclusive naming standard applies strictly to:
* **Project Source Code**: All files in `src/` and `include/` created for this wrapper.
* **Build Configuration**: Meson files and scripts.
* **Documentation**: Spec files, README, and meeting minutes.

**Decision**: The standard does NOT apply to the vendored `xxHash` source code in `vendor/`. This ensures the library can be updated to new upstream versions without maintaining a set of naming-related patches which could introduce logic errors or maintenance burden.

'''''

=== 21. Test Framework Selection

==== 21.1 Requirements Analysis

The project requires a testing framework that aligns with:

* **Build System**: Meson (exclusive)
* **Language Standard**: C99 (`-std=c99`)
* **Testing Types**: Unit tests, fuzz tests, benchmarks, ABI regression checks
* **Platforms**: x86/x64 (SSE2, AVX2, AVX512), ARM aarch64 (NEON, SVE)

==== 21.2 Framework Options Evaluated

[cols="1,2,2,2,2"]
|===
|Aspect |Unity |Check |cmocka |Current (Minimal)

|Meson Integration
|⭐⭐⭐⭐⭐ Excellent
|⭐⭐⭐⭐ Good
|⭐⭐⭐⭐ Good
|⭐⭐⭐⭐ Basic

|C99 Compatibility
|⭐⭐⭐⭐⭐ Full
|⭐⭐⭐⭐ Good
|⭐⭐⭐⭐⭐ Full
|⭐⭐⭐⭐⭐ Full

|Learning Curve
|⭐⭐⭐⭐ Easy
|⭐⭐⭐ Medium
|⭐⭐⭐⭐ Easy
|N/A

|Dependencies
|Zero (header-only)
|POSIX (-lcheck)
|External dep.
|None

|Features
|⭐⭐⭐⭐ Good
|⭐⭐⭐⭐ Excellent
|⭐⭐⭐⭐ Good
|Basic (0/1 exit)

|Maintenance
|⭐⭐⭐⭐ Active
|⭐⭐⭐⭐ Good
|⭐⭐⭐⭐ Good
|N/A
|===

==== 21.3 Detailed Evaluation

===== Unity (Rating: 9/10)

* **Pros**:
** Zero dependencies - single header file
** Header-only option available
** Native Meson integration via `meson.add_test_setup()`
** Lightweight (~2KB overhead)
** Industry proven (embedded, game engines, automotive)
** Easy test discovery and assertions
** Flexible (can use as header-only or compiled)

* **Cons**:
** No built-in mocking support (not required for this project)
** Less features than Check/cmocka (acceptable trade-off)

===== Check (Rating: 8/10)

* **Pros**: Mature, POSIX-based, excellent for regression testing
* **Cons**: Requires linking (`-lcheck -lsubunit`), heavier than Unity

===== cmocka (Rating: 7.5/10)

* **Pros**: From CMake project, clean API design
* **Cons**: External dependency required

==== 21.4 Fuzz Testing

* **libFuzzer**: Already integrated and working ✅ Keep
* Industry standard for fuzzing, integrates with GCC/Clang

==== 21.5 Benchmarking

* Current manual approach in `tests/bench/bench_variants.c` ✅ Keep
* Can add Criteri later if more sophisticated benchmarking needed

==== 21.6 Decision: Unity Framework

[IMPORTANT]
**FINAL DECISION**: The project adopts **Unity** as its unit testing framework.

*Unity is the optimal choice because:*
. Zero external dependencies (header-only)
. Native Meson integration
. Full C99 compliance
. Lightweight - appropriate for performance-critical library
. Active maintenance and community support
. Simple learning curve for contributors
. Matches project's modern, agile philosophy

==== 21.7 Implementation Plan

. Add Unity as Meson subproject or header-only include
. Migrate existing `tests/unit/test_variants.c` to use Unity test macros
. Keep libFuzzer for fuzz testing (already working)
. Keep manual benchmarks in `bench_variants.c`
. Continue using `scripts/check-abi.sh` for ABI regression checks

==== 21.8 Benefits of Unity Integration

* **Test Discovery**: Automatic test collection and reporting
* **Better Assertions**: Rich assertion macros with clear failure messages
* **CI Integration**: Native Meson test runner support
* **Maintainability**: Clear test structure for future contributors
* **Performance Focus**: Low overhead preserves benchmark accuracy
