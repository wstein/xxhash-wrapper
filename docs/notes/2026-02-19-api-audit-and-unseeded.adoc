== Meeting Minutes: API Audit and Unseeded Variants Implementation

=== Date: February 19, 2026

=== Attendees: Technical Review Team

'''''

=== 1. API Audit Summary

==== 1.1 Complete Vendor Function Mapping

This session performed a comprehensive audit of vendor xxHash functions vs wrapper
exports to identify gaps and ensure complete API coverage.

===== Vendor Functions EXPORTED by Wrapper

*XXH3 64-bit (Single-shot & Streaming)*
* `xxh3_64()` — dispatches to best variant (seeded)
* `xxh3_64_unseeded()` — dispatches to best variant (seed=0)
* `xxh3_64_<variant>()` — explicit variants: scalar, sse2, avx2, avx512, neon, sve (seeded)
* `xxh3_64_<variant>_unseeded()` — all 6 variants unseeded
* `xxh3_64_reset()` — start streaming with seed
* `xxh3_64_reset_unseeded()` — start streaming with seed=0
* `xxh3_64_update()` — consume input block
* `xxh3_64_digest()` — finalize and get result
* `xxh3_64_withSecret()` — single-shot with custom secret

*XXH3 128-bit (Single-shot & Streaming)*
* `xxh3_128()` — dispatches to best variant (seeded)
* `xxh3_128_unseeded()` — dispatches to best variant (seed=0)
* `xxh3_128_<variant>()` — explicit variants (seeded)
* `xxh3_128_<variant>_unseeded()` — all 6 variants unseeded
* `xxh3_128_reset()` — start streaming with seed
* `xxh3_128_reset_unseeded()` — start streaming with seed=0
* `xxh3_128_update()` — consume input block
* `xxh3_128_digest()` — finalize and get result
* `xxh3_128_withSecret()` — single-shot with custom secret

*XXH3 Streaming (Both 64 & 128)*
* `xxh3_reset_withSecret()` — streaming reset with custom secret (64 & 128 versions)
* `xxxh3_generateSecret()` — derive secret from seed
* `xxh3_copyState()` — deep copy streaming state for branching

*XXH32 & XXH64 (Legacy/Traditional)*
* `xxh32()` — scalar-only, no variants
* `xxh64()` — scalar-only (high-perf scalar fallback)
* Streaming: `xxh32_reset()`, `xxh32_update()`, `xxh32_digest()`
* Streaming: `xxh64_reset()`, `xxh64_update()`, `xxh64_digest()`

===== Vendor Functions NOT EXPORTED

*XXH3 with Secret AND Seed*
* `XXH3_64bits_withSecretandSeed()` — allows custom secret + custom seed together
* `XXH3_128bits_withSecretandSeed()` — 128-bit variant

Rational: These functions are rarely used in practice; consumers can derive a
secret from the seed using `xxh3_generateSecret()` and then use `withSecret()`.
Maintaining simplicity of the wrapper (per design philosophy) justifies omission.

*XXH3 Streaming Secret+Seed Reset*
* NO streaming reset variant that takes both secret AND seed
Rational: Not provided by vendor as streaming API; single-shot only.

*Additional Secret Derivation*
* `XXH3_generateSecret_fromSeed()` — generates secret directly from seed (vendor
provides this but we only expose the more general `xxh3_generateSecret()` that
takes custom seed bytes)

Rational: Wrapper exposes the more general form; direct seed-to-secret can be
replicated by creating a seed buffer and calling the general form.

*XXH128 Comparison Utilities*
* `XXH128_isEqual()` — compare two 128-bit hashes for equality
* `XXH128_cmp()` — compare two 128-bit hashes (for sorting with qsort/bsearch)

Rationale: Simple equality/comparison can be done with memcmp or direct struct
comparison in consumer code; omitting keeps wrapper's export surface minimal and
follows the "simple wrapper" philosophy.

*Canonical Representation (32 & 64)*
* `XXH32_canonicalFromHash()` / `XXH32_hashFromCanonical()`
* `XXH64_canonicalFromHash()` / `XXH64_hashFromCanonical()`

Rationale: These are for serializing hashes to network/storage in big-endian
canonical form. Not essential for all consumers; library provides base functions
to which consumer can add if needed. Omitting reduces complexity.

'''''

=== 2. Unseeded Variants Implementation (FR-024)

==== 2.1 Motivation

User question: "does xxh3 function _withSeed and wo/ _withSeed exported?" identified
that wrapper only exported seeded variants, forcing consumers to always provide a
seed even when they want the default (seed=0) behavior.

==== 2.2 Implementation Strategy

Simple delegation: All unseeded functions are one-line wrappers around seeded variants
with seed=0. This maintains the "simple wrapper" design philosophy.

Example pattern:
[source,c]
----
// In variant file (e.g., sve.c)
uint64_t xxh3_64_sve_unseeded(const void* input, size_t size)
{
    return XXH3_64bits_withSeed(input, size, 0);  // Simple delegation
}

// In wrapper dispatcher
uint64_t xxh3_64_unseeded(const void* input, size_t size)
{
#if defined(__aarch64__)
    return xxh3_64_neon_unseeded(input, size);  // Auto-select best variant
#elif defined(__x86_64__)
    return xxh3_64_avx2_unseeded(input, size);
#else
    return xxh3_64_scalar_unseeded(input, size);
#endif
}
----

==== 2.3 Scope

Added unseeded variants for:
* Single-shot: `xxh3_64_unseeded()`, `xxh3_128_unseeded()`
* All 6 SIMD variants: `xxh3_64_<variant>_unseeded()`, `xxh3_128_<variant>_unseeded()`
  - scalar, sse2, avx2, avx512 (x86)
  - neon, sve (aarch64)
* Streaming reset: `xxh3_64_reset_unseeded()`, `xxh3_128_reset_unseeded()`

Total: 16 new unseeded functions (8 single-shot + 8 streaming reset)

==== 2.4 Testing

* All functions compile without errors
* Unit test suite passes (confirms no regressions in seeded variants)
* Symbol table verified: all 10 unseeded dispatcher/reset functions present in shared library
* Backward compatibility: All existing seeded APIs remain unchanged

'''''

=== 3. Design Decisions & Justifications

==== 3.1 Why Not Export withSecretandSeed?

The wrapper philosophy is "simple delegation to vendor". The withSecretandSeed
variant is a specialized use case (custom secret + custom seed) that can be
achieved by consumers deriving a secret from the seed and calling withSecret().

This decision keeps the API surface manageable and reduces testing/maintenance burden.

==== 3.2 Why Not Export Comparison Utilities (XXH128_isEqual, XXH128_cmp)?

These are convenience functions for comparing two 128-bit hash results. Since the
128-bit hash is a simple struct with two 64-bit fields, consumers can:
* For equality: `(h1.low == h2.low) && (h1.high == h2.high)`
* For sorting: Use `memcmp()` or qsort's comparison mechanism

This follows the "simple wrapper" principle: the wrapper exports the core hashing
functions; utilities can easily be implemented by consumers.

==== 3.3 Why Not Export Canonical Functions?

Canonical representation (converting hash values to big-endian byte buffers for
network/storage) is not essential for all consumers. The wrapper focuses on the
core XXH3 hashing functionality; consumers needing canonical form can implement it
in their own code.

'''''

=== 4. Documentation Updates

==== 4.1 CHANGELOG

Added new entry documenting unseeded single-shot and streaming variants for all
XXH3 functions, including all architecture-specific variants.

==== 4.2 README

Updated "Public API" section to explicitly list:
* Seeded single-shot with dispatcher
* Unseeded single-shot with dispatcher
* Architecture-specific unseeded variants
* Streaming unseeded reset functions
* Distinction between seeded and unseeded

==== 4.3 Specifications (spec.md)

Added FR-024 (Functional Requirement):
"Library MUST export unseeded variants of all XXH3 single-shot and streaming
reset functions... Unseeded variants are thin wrappers that delegate to the
seeded variant with seed=0, maintaining internal code simplicity."

==== 4.4 Meeting Minutes

This document (2026-02-19) provides complete audit results and rationale for
which vendor functions ARE and ARE NOT exported.

'''''

=== 5. Key Takeaways

1. Wrapper consistently delegates to vendor; no custom hash logic
2. Consumer dispatch responsibility aligns with "simple wrapper" philosophy
3. Unseeded variants address user request for default-seed API
4. Significant vendor functions intentionally NOT exported due to limited-use
   patterns (can be layered by consumers if needed)
5. Library now provides both seeded and unseeded XXH3 APIs across all variants
6. Full backward compatibility maintained

'''''

=== 6. Implementation of Previously Omitted Functions (Phase 4)

==== 6.1 Philosophy Shift: From "Selective Omission" to "Complete Coverage with Consumer Choice"

After initial API audit, user decision was made to reverse the omission of the
eight previously identified vendor functions. Rationale: Rather than restricting
the API based on perceived "simplicity", the wrapper should export all functions
and **let consumers decide** which to use.

==== 6.2 Eight Functions Implemented & Exported

===== Re-exported vendor delegates

The wrapper now **re-exports vendor implementations** for the previously
controversial helpers as *thin delegates* (no custom mixing/derivation logic in
wrapper code). The following wrapper functions are now thin delegates to the
vendor equivalents:

* `xxh3_64_withSecretandSeed()` → `XXH3_64bits_withSecretandSeed()`
* `xxh3_128_withSecretandSeed()` → `XXH3_128bits_withSecretandSeed()`
* `xxh3_generateSecret_fromSeed()` → `XXH3_generateSecret_fromSeed()`

Rationale:
* Maintain a delegate-only wrapper surface while making vendor functionality
  available to consumers via the wrapper.
* Avoid duplicating vendor derivation/mixing logic in the wrapper; delegate to
  the authoritative vendor implementation instead.

All three functions are thin wrappers (single-line delegates) and are exported
by the wrapper for consumers that require them. The wrapper still exposes the
other small convenience delegates (comparison utilities and canonical
conversion functions) as before.

===== XXH128 Comparison Utilities

*Functions*:
* `int xxh3_128_isEqual(xxh3_128_t h1, xxh3_128_t h2)`
* `int xxh3_128_cmp(xxh3_128_t h1, xxh3_128_t h2)` (qsort-compatible)

*Implementation Strategy*: Type-Safe Struct Conversion Wrappers
* Convert wrapper struct fields (h1.high, h1.low) to vendor struct (XXH128_hash_t)
* Delegate to vendor comparison functions
* Return comparison result directly

*Rationale*: Vendor provides these utilities; wrapper comparison wrappers provide
type-safe conversion between wrapper types and vendor internal types.

===== XXH32 & XXH64 Canonical Representation

*Functions*:
* `xxh32_canonical_t xxh32_canonicalFromHash(uint32_t hash)`
* `uint32_t xxh32_hashFromCanonical(xxh32_canonical_t canonical)`
* `xxh64_canonical_t xxh64_canonicalFromHash(uint64_t hash)`
* `uint64_t xxh64_hashFromCanonical(xxh64_canonical_t canonical)`

*Type Definitions*:
[source,c]
----
typedef struct {
    unsigned char digest[4];  // 32-bit hash as 4 bytes (big-endian)
} xxh32_canonical_t;

typedef struct {
    unsigned char digest[8];  // 64-bit hash as 8 bytes (big-endian)
} xxh64_canonical_t;
----

*Implementation Strategy*: Type-Safe Big-Endian Conversion
* Convert between hash value and big-endian byte representation
* Wrapper types separate from vendor internal types
* Maintain clean API boundary

*Rationale*: Canonical representation is essential for network/storage serialization.
Separate wrapper typedefs maintain type safety without exposing vendor internals.

==== 6.3 Testing & Validation

* ✅ All 8 functions compile without errors in both shared and static libraries
* ✅ Full unit test suite passes (no regressions in existing functionality)
* ✅ Symbol table verified: all 8 functions present and exported in shared library
* ✅ Backward compatibility maintained: all existing APIs unchanged

==== 6.4 Documentation Updates

* **README.md**: Public API section updated to document all 8 new functions
* **specs/spec.md**: New FR-025 section added (Optional Advanced Function Support)
* **CHANGELOG.md**: Entry added documenting implementation of optional functions
* **This document**: Complete rationale and implementation strategy documented

==== 6.5 Design Rationale

The shift from "omit unless essential" to "export all, let consumers choose" reflects:

1. **Consumer Agency**: Developers can decide which functions they need
2. **Future-Proofing**: All vendor xxHash functions now available; no need for separate bindings
3. **Simplicity**: All implementations are thin delegators or type-safe wrappers (no custom logic)
4. **No Bloat**: Canonical functions and comparison utilities are small; minimal code/compile impact
5. **Type Safety**: Wrapper-specific types (xxh32_canonical_t, xxh64_canonical_t) prevent accidental type confusion

'''''

=== 7. Next Steps

* Monitor API usage patterns in downstream consumers (cr-xxhash, other bindings)
* Continue testing across all supported platforms
* Gather feedback on whether additional wrapper utilities would be beneficial
